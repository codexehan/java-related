package codexe.han.nio.doc;

/**
 * 阻塞io模型
 * 用户发送io请求，内核会去查看数据是否就绪，用户线程会处于阻塞状态，用户线程交出cpu，
 * 当数据就绪之后，内核会将数据拷贝到用户线程，并返回给用户线程，用户线程才解除block状态
 *
 * 非阻塞io模型
 * 不出让cpu，while循环中不断地询问内核数据是否就绪，
 *
 * 多路复用io模型
 * 一个线程不断地轮询多个socket状态，只有socket真的有读写事件的时候，才调用io操作
 * 适合连接数比较多的情况
 *
 * 非阻塞io不断地询问socket状态是在用户态进行的，而多路复用是在，内核状态下询问socket状态，效率要高的多
 *
 * 信号驱动io模型
 * 用户线程发起io操作，会给socket注册一个信号函数，然后用户线程继续执行，内核数据就绪的时候，发送一个信号给用户线程，
 * 用户线程收到信号之后，在信号函数中进行读写
 *
 * 异步io模型
 * 从内核角度，当他收到一个asysc read的时候，会立刻返回，说明read请求已经发送成功，因此不会对用户线程产生任何block，
 * 然后内核会等待数据完成，将数据拷贝到用户状态，用户线程不需要再次调用io操作
 *
 * 信号驱动io中，收到信号，需要在用户态下调用io操作，异步io模型，收到信号，表示io操作已经完成。
 *
 * 异步io操作是需要底层操作系统支持的
 */
public class ios {
}
