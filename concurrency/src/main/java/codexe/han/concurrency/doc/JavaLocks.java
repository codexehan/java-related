package codexe.han.concurrency.doc;

/**
 * 1.乐观锁 java cas compare and sweep
 * 认为读多写少
 * 读的时候不加锁，写的时候，先去读当前版本号，然后加锁，比较上一次版本号，如果一样则更新，否则失败
 *
 * 2.悲观锁  java synchronized
 * 认为写多
 * 每次读写数据都会加锁
 *
 * AQS框架先尝试cas乐观锁去获取锁，获取不到，才会转为悲观锁
 *
 * 3.自旋锁
 * 如果持有锁的线程能在很短的时间内释放资源，name等待竞争锁的线程就不需要做内核态和用户态之间的切换进入blocking status.
 * 他们只需要等一等（自旋），等持有锁的线程释放锁后即可like获取锁
 *
 * 线程自旋是需要消耗cpu的，所以需要设定一个自旋的最大等待时间
 *
 * 优点：占用锁的时间非常短的话，性能大幅提升，但是如果锁竞争比较激烈的话，而且获取锁的时间比较长，就会浪费资源
 *
 * 如何选择自旋时间？
 * 适应性自旋锁
 * 时间由前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定
 *
 * 4.synchronized
 * 独占式悲观锁，可重入
 * 作用范围：
 * a.作用于方法的时候，锁住的是该对象this
 * b.作用于静态方法时，锁住的对象是Class实例，因为Class的相关数据存储在永久带PermGen(metaspace)？？？？方法区，永久带是全局共享的，
 * 因此相当于一个全局锁，会锁住所有调用该方法的线程
 * c.作用于一个对象实例，锁住的是所有以该对象为锁的代码块。他有对个队列 ，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。
 *
 * 核心组件
 * a.wait set: 调用wait方法被阻塞的线程
 * b.contention list: 竞争队列，所有请求锁的线程首先被放在这个竞争队列中
 * c.entry list: contention list中有资格成为候选的线程被移动到entry list中
 * d.ondeck: 任意时刻，最多只有一个线程正在竞争锁资源
 * e.owner当前已经获得所有资源的线程
 * f.!owner当前释放锁的线程
 *
 * 为了优化synchronized,java引入了轻量级锁，偏向锁
 * 四种状态：无锁状态，偏向锁，轻量级锁和重量级锁
 * 首先明白锁是可以升级的，随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级到重量级锁，只能升级不能降级
 *
 * 偏向锁
 * 从始至终只有一个线程请求某一把锁，是轻量级锁的更进一步的乐观情况
 *
 * 轻量级锁
 * 多个线程在不同时间段请求同一把锁，也就是没有锁竞争
 *
 * 重量级锁 Mutex Lock
 * 应该减少重量级锁的使用
 *
 * 锁的优化
 * a.减少锁持有时间
 * b.减少锁粒度
 * c.锁分离
 * 读写分离
 * d.锁粗化
 * 为了保证多线程并发，会尽量减少持有锁的时间，但是，如果对一个锁不停的进行请求，同步和释放，其本身会消耗巨大资源
 * e.锁消除
 * 编译器会在编译期间，发现不可能被共享的对象，会消除这些对象的锁操作
 *
 */
public class JavaLocks {

}
