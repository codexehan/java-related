package codexe.han.concurrency.tools;

public class VariousLock {
    /**
     * 乐观锁 CAS
     * 悲观锁 synchronized  reentrentlock
     * 自旋锁 如果持有锁的线程能在很短的时间内释放锁资源，那么等待竞争锁的线程就不需要做"内核态"和"用户态"之间的切换进入阻塞挂起状态，他们只需要等一等（自旋）。从而避免用户线程和内核的切换的销号
     *
     */

    /**
     * kernel space 和 user pace
     *      * 对于32位操作系统而言，寻址空间（虚拟地址空间，或线性地址空间）为4G(2的32次方)。也就是说一个进程最大的地址空间为4G.
     *      * 其中最高1G字节（0xC0000000 - 0xFFFFFFF）有内核使用，称为内核空间，较低3G字节，由各个进程使用，称为用户空间
     *      * 每个进程的4G地址空间，最高1G都是一样的，及内核空间。换句话说，最高1G的内核空间是被所有进程共享的！
     * 为什么要区分内核空间和用户空间
     *      CPU指令中，有些指令是非常危险的，禁止用户使用。Linux系统指令分为Ring0和Ring3两个级别。Ring3是用户态，Ring0是内核态
     * 什么是内核态 用户态
     *      进程运行在内核空间就是内核态，运行在用户空间就是用户态
     * 从用户空间进入内核空间
     *      比如写磁盘文件，分配回收内存，从网络接口读写数据，都是内和空间下完成的，我们的应用程序只能通过内核提供的接口来完成这样的操作。
     *      比如要应用程序要读取磁盘上的一个文件，他可以像内核发起一个系统调用告诉内核：读取磁盘文件。其实就是通过一个特殊指令让进程从用户态进入到内核态。在内核空间中，CPU先把数据读取到内核空间中，然后再把数据拷贝到用户空间并从内核态切换到用户态。
     * 用户态进入内核态的方式：
     *      系统调用
     *
     *      软中断
     *
     *      硬件中断
     *          时钟，外设
     *
     */
}
